### example

example 采用的是 hashjoin 的方式来进行 join的。
对于 hashjoin 的 join 方式来讲，hashjoin 只支持等值连接，题目只有等值连接，符合题意但适用范围较小。

example 在执行 join 的过程中，没有判断两个文件的大小，直接对 table1 进行建立 hashtable 。最好使用更小的表进行 hashtable 来构建，用大一点的表进行探测。

### join join算法主要三种算法

### 循环嵌套算法

循环嵌套算法是非常普适的一种算法，他是绝对正确的，时间复杂度取决于两张表的大小，我测了一下，在给出的 r0, r1, 和 r2 的数据上是 example 这种单线程 hashjoin 的四倍.. 这个不提，只是用这个来确定一下作业是否理解正确


### hashjoin

hashjoin 作为连接算法有它固有的弊端，他只能支持等值连接，但是正因为此，它在等值连接的方面是非常快的。
仔细分析 hashjoin 的过程会发现，两张表做连接，实际上是两个过程，一个对其中一个表建立 hash 表的过程，一个对 hash 表进行探测的过程。

因为要对 hash 表进行探测，所以这两个过程有着严格的先后关系，我们进行探测时，hash 表一定需要建立完毕。

分析建表过程，hashtable 作为一个数据结构，不允许多个 goroutine 同时对其进行修改，因此也就失去了并发的必要。
但考虑可以通过建立多个小的 hashtable, 再合并成一个大的 hashtable 。 (并没有实现，也没有证明是否真的能够加速 hashtable 的建立)

分析探测过程，探测过程作为多个 goroutine 同时读取 hashtable 的数据，不存在冲突与数据争用的问题，是满足并发的条件的。

初步实现了通过多个 goroutine 进行探测一个管道传输探测到数据，在主程序中进行求和的简单程序。
可以通过小数据的测试，但是我下载了 r7 和 r8 两个大的数据集，go test 测试的时候，电脑死机了... 
我猜测是因为同时调用了非常非常多的 goroutine 然后内存不够了...
使用了 tidb 的数据结构以后发现自己写了一个 example 的并发版，觉得自己写的非常的简陋，但是还不知道如何优化。

hashtable 的探测时间复杂度是 O(1) 的，在考虑并发探测过程的时候，我觉得这是一个 io 影响还是计算影响的问题，如果是探测过程本身比较耗时，就有并发的必要，如果探测过程本身的开销很小，不足以抵消 goroutine 调度的开销，那就不值得对此进行并发。

### 并发的归并连接

并发的归并连接是我在上述 hashjoin 的分析以后非常想完成的一个算法，但是自己水平有限，目前并没有完成。
归并连接的基础和限制就是归并排序以及他的开销上，归并排序在 week1 中其实已经有完成简单的数组排序，归并排序本身是可以并发的，而完成归并排序以后的扫描其实开销并不是很大，但归并连接本身可能还是太慢。

看到有论文的结论是利用多核心，缓存良好的归并连接，在时间上可以接近于 hashjoin ，感觉自己还挺凉的。

### ~~结束语~~

非常感谢 PingCAP 能够有这样的一次机会去了解 go 这个新语言 ~~应该是新语言吧~~ ， 也对 tidb 有了很多的了解，觉得是一次非常好的机会，如果有下次还想参加！